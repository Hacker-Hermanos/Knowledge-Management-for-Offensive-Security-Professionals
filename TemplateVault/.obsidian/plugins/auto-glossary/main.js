/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => autoGlossary
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/modal.ts
var import_obsidian = require("obsidian");

// src/utils.ts
function getEnumFT(value) {
  let result;
  switch (value.toLowerCase()) {
    case "glossary":
      result = "glossary" /* g */;
      break;
    case "index":
      result = "index" /* i */;
      break;
    case "glossaryindex":
      result = "glossaryIndex" /* gi */;
      break;
    default:
      result = "glossaryIndex" /* gi */;
      break;
  }
  return result;
}
function getEnumFO(value) {
  let result;
  if (!value) {
    return "default" /* default */;
  } else {
    switch (value.toLowerCase()) {
      case "default":
        result = "default" /* default */;
        break;
      case "mtime_new":
        result = "mtime_new" /* mtime_new */;
        break;
      case "mtime_old":
        result = "mtime_old" /* mtime_old */;
        break;
      case "ctime_new":
        result = "ctime_new" /* ctime_new */;
        break;
      case "ctime_old":
        result = "ctime_old" /* ctime_old */;
        break;
      case "alphabetical":
        result = "alphabetical" /* alphabetical */;
        break;
      case "alphabetical_rev":
        result = "alphabetical_rev" /* alphabetical_rev */;
        break;
      default:
        result = "default" /* default */;
        break;
    }
  }
  return result;
}
async function fileExists(app, fileName) {
  const adapter = app.vault.adapter;
  const result = await adapter.exists(fileName + ".md");
  if (result) {
    console.log("Already existing file " + fileName + ".md");
  }
  return result;
}
async function cleanFiles(app, notesTFiles) {
  const { vault } = app;
  const cleanedNotes = [];
  notesTFiles.forEach(async (file) => {
    const fileContent = await vault.cachedRead(file);
    if (!fileContent.contains("---\ntags: obsidian-auto-glossary\n---\n")) {
      cleanedNotes.push(file);
    }
  });
  return cleanedNotes;
}
function sortFiles(notesTFile, fileOrder2) {
  switch (fileOrder2) {
    case "ctime_new":
      notesTFile.sort((a, b) => b.stat.ctime - a.stat.ctime);
      break;
    case "ctime_old":
      notesTFile.sort((a, b) => a.stat.ctime - b.stat.ctime);
      break;
    case "mtime_new":
      notesTFile.sort((a, b) => b.stat.mtime - a.stat.mtime);
      break;
    case "mtime_old":
      notesTFile.sort((a, b) => a.stat.mtime - b.stat.mtime);
      break;
    case "alphabetical":
      notesTFile.sort((a, b) => {
        const nameA = a.name.toUpperCase();
        const nameB = b.name.toUpperCase();
        if (nameA < nameB) {
          return -1;
        }
        if (nameA > nameB) {
          return 1;
        }
        return 0;
      });
      break;
    case "alphabetical_rev":
      notesTFile.sort((a, b) => {
        const nameA = a.name.toUpperCase();
        const nameB = b.name.toUpperCase();
        if (nameA > nameB) {
          return -1;
        }
        if (nameA < nameB) {
          return 1;
        }
        return 0;
      });
      break;
    case "default":
    default:
      break;
  }
  return notesTFile;
}

// src/modal.ts
var CreateFileModal = class extends import_obsidian.Modal {
  constructor(app, overwrite, sameDest, destFolder, fileOrder2, onSubmit, passedFolder, passedName, passedOption) {
    super(app);
    this.onSubmit = onSubmit;
    this.overwrite = overwrite;
    this.sameDest = sameDest;
    this.destFolder = destFolder ? destFolder : "";
    this.fileOrder = fileOrder2 ? fileOrder2 : "default";
    this.chosenFolder = passedFolder ? passedFolder : "";
    this.fileName = passedName ? passedName : "";
    this.option = passedOption ? passedOption : "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "AutoGlossary" });
    new import_obsidian.Setting(contentEl).setName("Folder: " + this.chosenFolder);
    new import_obsidian.Setting(contentEl).setName("Same destination as folder").setDesc("If on, the file will be created in the same folder specified above and the 'Destination' field will be disabled.").addToggle((toggle) => toggle.setValue(this.sameDest).onChange((value) => {
      this.sameDest = value;
      destination.setDisabled(value);
      if (value) {
        this.destFolder = this.chosenFolder;
      }
    }));
    const destination = new import_obsidian.Setting(contentEl);
    destination.setName("Destination").setDesc("If the above toggle is off, specify here the destination folder for the file created.").addText((text) => text.onChange((value) => {
      this.destFolder = value;
    }).setValue(this.destFolder).setDisabled(true)).setDisabled(this.sameDest);
    new import_obsidian.Setting(contentEl).setName("File name").setDesc("The name of the created file.").addText((text) => text.onChange((value) => {
      this.fileName = value;
    }).setValue(this.fileName));
    new import_obsidian.Setting(contentEl).setName("Overwrite existing file").setDesc("If turned on, if a file with the same name and location already exists, it will be overwritten. Default behavior can be changed in the plugin settings.").addToggle((toggle) => toggle.setValue(this.overwrite).onChange((value) => {
      this.overwrite = value;
    }));
    new import_obsidian.Setting(contentEl).setName("File order").setDesc("The order for the files to be indexed.").addDropdown((drop) => drop.addOption("default", "Default").addOption("mtime_new", "Modification time - Newest to oldest").addOption("mtime_old", "Modification time - Oldest to newest").addOption("ctime_new", "Creation time - Newest to oldest").addOption("ctime_old", "Creation time - Oldest to newest").addOption("alphabetical", "Alphabetical").addOption("alphabetical_rev", "Alphabetical - Reverse").setValue(this.fileOrder).onChange((chosen) => {
      this.fileOrder = chosen;
    }));
    new import_obsidian.Setting(contentEl).setName("File type").setDesc("Choose between index, glossary or both.").addDropdown((drop) => drop.addOption("glossary" /* g */, "Glossary").addOption("index" /* i */, "Index").addOption("glossaryIndex" /* gi */, "Glossary with index").onChange((chosen) => {
      this.option = chosen;
    }).setValue(this.option ? this.option : "glossaryIndex" /* gi */));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => {
      if (!this.fileName) {
        this.fileName = this.option;
      }
      this.close();
      this.onSubmit(this.option, this.overwrite, this.fileName, this.chosenFolder, this.fileOrder, this.destFolder);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/glossaryIndex.ts
var import_obsidian2 = require("obsidian");
async function createArrays(app, requestedFile, fileInclusion, fileName, chosenFolder, fileOrder2) {
  let notesTFile = app.vault.getMarkdownFiles();
  const notes = [];
  if (!fileInclusion) {
    notesTFile = await cleanFiles(app, notesTFile);
  }
  if (fileOrder2) {
    notesTFile = sortFiles(notesTFile, fileOrder2);
  }
  notesTFile.forEach((file) => {
    if (chosenFolder && file.path.includes(chosenFolder) || !chosenFolder) {
      notes.push(file.name);
    }
  });
  const glossaryArray = [];
  const indexArray = [];
  notes.forEach((note) => {
    const noteName = note.slice(0, -3);
    if (requestedFile == "glossaryIndex" /* gi */) {
      indexArray.push("- [[" + fileName + "#" + noteName + "|" + noteName + "]]\n");
    } else {
      indexArray.push("- [[" + noteName + "]]\n");
    }
    glossaryArray.push("#### ![[" + noteName + "]]\n\n***\n\n");
  });
  const indexText = "## Index\n" + indexArray.toString().replace(/,-\s\[\[/g, "- [[");
  const glossaryText = "## Glossary\n" + glossaryArray.toString().replace(/,####\s!\[\[/g, "#### ![[");
  return [indexText, glossaryText];
}
async function createFile(app, requestedFile, fileInclusion, fileOverwrite, fileName, chosenFolder, fileOrder2, destFolder) {
  let completeFileName = "";
  if (destFolder) {
    if (fileName) {
      completeFileName = (0, import_obsidian2.normalizePath)(destFolder + "/" + fileName);
    } else {
      completeFileName = (0, import_obsidian2.normalizePath)(destFolder + "/" + requestedFile);
    }
  } else if (chosenFolder) {
    if (fileName) {
      completeFileName = (0, import_obsidian2.normalizePath)(chosenFolder + "/" + fileName);
    } else {
      completeFileName = (0, import_obsidian2.normalizePath)(chosenFolder + "/" + requestedFile);
    }
  } else {
    completeFileName = (0, import_obsidian2.normalizePath)(requestedFile);
  }
  const fileExistsBool = await fileExists(app, completeFileName);
  const adapter = app.vault.adapter;
  console.log("destFolder: " + destFolder);
  console.log("fileName: " + fileName);
  console.log("requestedFile: " + requestedFile);
  console.log("chosenFolder: " + chosenFolder);
  console.log("completeFileName: " + completeFileName);
  if (fileExistsBool && !fileOverwrite) {
    new import_obsidian2.Notice(`${completeFileName} file already exists. Try again with overwrite enabled or a different file name.`);
  } else {
    adapter.write(completeFileName + ".md", await createText(app, requestedFile, fileInclusion, fileName, chosenFolder, fileOrder2));
    new import_obsidian2.Notice(`${completeFileName} file updated`);
  }
}
async function createText(app, requestedFile, fileInclusion, fileName, chosenFolder, fileOrder2) {
  const array = await createArrays(app, requestedFile, fileInclusion, fileName, chosenFolder, fileOrder2);
  let text = "---\ntags: obsidian-auto-glossary\n---\n";
  switch (requestedFile) {
    case "glossary" /* g */:
      text += array[1];
      break;
    case "index" /* i */:
      text += array[0];
      break;
    case "glossaryIndex" /* gi */:
      text += array[0] + "\n***\n\n" + array[1];
      break;
    default:
      break;
  }
  return text;
}

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  fileInclusion: false,
  sameDest: true,
  fileDest: "",
  fileOverwrite: false,
  fileOrder: "default"
};
var SettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Auto Glossary Settings" });
    new import_obsidian3.Setting(containerEl).setName("File inclusion").setDesc("Include previously generated files in glossaries and indexes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileInclusion).onChange(async (value) => {
      console.log("fileInclusion switched to " + value);
      this.plugin.settings.fileInclusion = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Default options" });
    new import_obsidian3.Setting(containerEl).setName("Same destination as folder").setDesc("If on, files will be created in the same folder specified above and the 'Destination' field will be disabled.").addToggle((toggle) => toggle.setValue(this.plugin.settings.sameDest).onChange(async (value) => {
      console.log("sameDest switched to " + value);
      this.plugin.settings.sameDest = value;
      if (value) {
        this.plugin.settings.fileDest = "";
      }
      destination.setDisabled(value);
      await this.plugin.saveSettings();
    }));
    const destination = new import_obsidian3.Setting(containerEl);
    destination.setName("Destination").setDesc("If the above toggle is off, specify here the destination folder for the files created.").addText((destText) => destText.onChange(async (value) => {
      this.plugin.settings.fileDest = value;
      console.log("fileDest switched to " + value);
      await this.plugin.saveSettings();
    }).setValue(this.plugin.settings.fileDest).setDisabled(true)).setDisabled(this.plugin.settings.sameDest);
    new import_obsidian3.Setting(containerEl).setName("Overwrite existing files").setDesc("Set the default behavior when a file already exists. Can be changed every time in the modal.").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileOverwrite).onChange(async (value) => {
      console.log("fileOverwrite switched to " + value);
      this.plugin.settings.fileOverwrite = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("File order").setDesc("The order for the files to be indexed.").addDropdown((drop) => drop.addOption("default", "Default").addOption("mtime_new", "Modification time - Newest to oldest").addOption("mtime_old", "Modification time - Oldest to newest").addOption("ctime_new", "Creation time - Newest to oldest").addOption("ctime_old", "Creation time - Oldest to newest").addOption("alphabetical", "Alphabetical").addOption("alphabetical_rev", "Alphabetical - Reverse").setValue(this.plugin.settings.fileOrder).onChange(async (chosen) => {
      console.log("fileOrder switched to " + chosen);
      this.plugin.settings.fileOrder = chosen;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var autoGlossary = class extends import_obsidian4.Plugin {
  async onload() {
    console.info("Auto Glossary enabled");
    await this.loadSettings();
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("New index").setIcon("list").onClick(async () => {
            createFile(this.app, "index" /* i */, this.settings.fileInclusion, this.settings.fileOverwrite, folder.name + "_Index", folder.path, getEnumFO(this.settings.fileOrder), this.settings.sameDest ? "" : this.settings.fileDest);
          });
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("New glossary").setIcon("layout-list").onClick(async () => {
            createFile(this.app, "glossary" /* g */, this.settings.fileInclusion, this.settings.fileOverwrite, folder.name + "_Glossary", folder.path, getEnumFO(this.settings.fileOrder), this.settings.sameDest ? "" : this.settings.fileDest);
          });
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("New index+glossary").setIcon("list-ordered").onClick(async () => {
            createFile(this.app, "glossaryIndex" /* gi */, this.settings.fileInclusion, this.settings.fileOverwrite, folder.name + "_GlossaryIndex", folder.path, getEnumFO(this.settings.fileOrder), this.settings.sameDest ? "" : this.settings.fileDest);
          });
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("Advanced index").setIcon("list").onClick(async () => {
            new CreateFileModal(this.app, this.settings.fileOverwrite, this.settings.sameDest, this.settings.fileDest, this.settings.fileOrder, (option, overwrite, fileName, chosenFolder, fileOrder2, destFolder) => {
              createFile(this.app, getEnumFT(option), this.settings.fileInclusion, overwrite, fileName, chosenFolder, getEnumFO(fileOrder2), destFolder);
            }, folder.path, folder.name + "_Index", "index" /* i */).open();
          });
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("Advanced glossary").setIcon("layout-list").onClick(async () => {
            new CreateFileModal(this.app, this.settings.fileOverwrite, this.settings.sameDest, this.settings.fileDest, this.settings.fileOrder, (option, overwrite, fileName, chosenFolder, fileOrder2, destFolder) => {
              createFile(this.app, getEnumFT(option), this.settings.fileInclusion, overwrite, fileName, chosenFolder, getEnumFO(fileOrder2), destFolder);
            }, folder.path, folder.name + "_Glossary", "glossary" /* g */).open();
          });
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, folder) => {
      if (folder instanceof import_obsidian4.TFolder) {
        menu.addItem((item) => {
          item.setTitle("Advanced index+glossary").setIcon("list-ordered").onClick(async () => {
            new CreateFileModal(this.app, this.settings.fileOverwrite, this.settings.sameDest, this.settings.fileDest, this.settings.fileOrder, (option, overwrite, fileName, chosenFolder, fileOrder2, destFolder) => {
              createFile(this.app, getEnumFT(option), this.settings.fileInclusion, overwrite, fileName, chosenFolder, getEnumFO(fileOrder2), destFolder);
            }, folder.path, folder.name + "_GlossaryIndex", "glossaryIndex" /* gi */).open();
          });
        });
      }
    }));
    this.addSettingTab(new SettingTab(this.app, this));
  }
  onunload() {
    console.info("Auto Glossary unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("Settings saved.");
  }
};
